Introdução:

Como esse é um conteúdo um pouco denso e a gente já viu bastante coisa sobre eu vou fazer o seguinte: eu vou descrever o que cada item é e como ele funciona e em seguida explico ele, aí caso a primeira parte do que eu falei tenha ficado meio confusa, até porque são bastante termos que demora um pouco pra se familiarizar, então vou sempre tentar ser mais simples quando for explicar o que acabei de falar.

Escalonamento por Múltiplas Filas:

No escalonamento por múltiplas filas existem diversas filas de processos no estado de pronto, cada qual com uma prioridade específica. Os processos são associados às filas em função de características próprias, como importância para a aplicação, tipo de processamento ou área de memória necessária.
Como processos possuem características de processamento distintas, é difícil que um único mecanismo de escalonamento seja adequado a todos. A principal vantagem de múltiplas filas é a possibilidade da convivência de mecanismos de escalonamento distintos em um mesmo sistema operacional. Cada fila possui um mecanismo próprio, permitindo que alguns processos sejam escalonados pelo mecanismo FIFO, enquanto outros pelo escalonamento circular.

IMAGEM_MULTIPLAS_FITAS

EXPLICAÇÃO:

Esse mecanismo de escalonamento maximiza o throughput, minimiza o turnaround, aumenta a utilização da CPU e minimiza o tempo de espera e resposta, além de também não degradar o sistema. Tudo isso porque mais formas de escalonamento ocorrerão, fazendo com que o máximo de processos receba recursos, aplicando-se prioridade dinâmica e formando um ciclo que evita que eles entrem em starvation.

Cada fila tem prioridade absoluta sobre as filas de prioridade mais baixa. Por exemplo: nenhum processo na fila de batch poderia ser executado a menos que as filas system, interactive e interactive editing estejam todas vazias. Se um processo de interactive editing entrou na fila de processos prontos para execução enquanto um processo em batch estava em execução, o processo em batch seria interrompido.

"Operating system concepts 8th ed. Hoboken"

IMAGEM_CONCLUSÃO_MULTIPLAS_FITAS




Escalonamento por Múltiplas Filas com Realimentação:

O escalonamento por múltiplas filas com realimentação é parecido com o escalonamento por múltiplas filas, mas os processos podem trocar de filas durante seu processamento. A sacada é permitir ao sistema operacional identifique dinamicamente o comportamento de cada processo, direcionando-o para filas com prioridade de execução e mecanismo de escalonamento mais adequados ao longo de seu processamento. 

Esse esquema permite que os processos sejam redirecionados entre as diversas filas, fazendo com que o sistema operacional implemente um mecanismo adaptativo. Os processos não são previamente associados às filas de pronto, e, sim, direcionados pelo sistema para as filas existentes com base no seu comportamento.

Um mecanismo FIFO adaptado com fatia de tempo é implementado para escalonamento em todas as filas, com exceção da fila de menor prioridade, que utiliza o escalonamento circular. O escalonamento de um processo em uma fila ocorre apenas quando todas as outras filas de prioridades mais altas estiverem vazias. A fatia de tempo em cada fila varia em função da sua prioridade, ou seja, quanto maior a prioridade da fila menor a sua fatia de tempo, é possível visualizar de maneira mais clara na imagem abaixo. Assim, a fatia de tempo concedida aos processos varia em função da fila de pronto na qual ele se encontra. Um processo, quando criado, entra no final da fila de maior prioridade, porém durante sua execução, a cada preempção por tempo, o processo é redirecionado para uma fila de menor prioridade.


IMAGEM_MULTIPLAS_FITAS_REALIMENTAÇÃO


o escalonamento por múltiplas fitas é definido pelos seguintes parâmetros:
1.	O número de filas;
2.	O algoritmo de escalonamento de cada fila;
3.	O método usado para determinar quando atualizar um processo para uma fila de maior prioridade;
4.	O método usado para determinar quando rebaixar um processo para uma fila de prioridade mais baixa;
5.	O método usado para determinar em qual fila um processo entrará quando aquele processo precisa de serviço.
A definição de um escalonador por múltiplas fitas o torna o mais genérico algoritmo de escalonamento de CPU. Pode ser configurado para corresponder a um sistema em projeto. Infelizmente, é também o algoritmo mais complexo, uma vez que definir o melhor escalonador requer alguns meios para selecionar valores para todos os parâmetros.

IMAGEM 2 DA FITA DE REALIMENTAÇÃO

Este algoritmo de escalonamento dá maior prioridade a qualquer processo com um burst de CPU de 8 milissegundos ou menos. Esse processo irá rapidamente obter a CPU, terminar seu burst de CPU e vai para o próximo burst de I/O. Processos que precisam mais do que 8, mas menos de 24 milissegundos também são servidos rapidamente, embora com menor prioridade do que processos mais curtos. Processos longos vão automaticamente para a fila 2 e são atendidos na ordem FCFS com quaisquer ciclos de CPU que sobraram das filas 0 e 1. Esse exemplo é, em minha opinião, muito bem compreensível. Pois agora as políticas de escalonamento estão cada vez mais complexas, e mais atuais também.


IMAGEM_CONCLUSÃO_MULTIPLAS_FITAS_REALIMENTAÇÃO


BIS MULTIPLAS FITAS REALIMENTAÇÃO:

Vale dizer também que o escalonamento por multiplas filas de realimentação é um algoritmo de escalonamento bem generalista, podendo ser implementado em qualquer tipo de sistema operacional. E também é um dos mais complexos de se implementar.


Política de Escalonamento em Sistemas de Tempo Compartilhado

Em geral, sistemas de tempo compartilhado caracterizam-se pelo processamento interativo, no qual usuários interagem com as aplicações exigindo tempos de respostas baixos. A escolha de uma política de escalonamento para atingir este propósito deve levar em consideração o compartilhamento dos recursos de forma equitativa para possibilitar o uso balanceado da UCP entre processos. Neste item, serão analisados os comportamentos de um processo CPU-bound e outro I/O-bound, nos principais escalonamento apresentados.
Como dá pra ver na figura, os processos A (CPU-bound) e B (I/O-bound) são escalonados segundo o mecanismo FIFO. Se contabilizarmos o uso da UCP para cada processo no instante de tempo 27, constataremos que o processador está sendo distribuído de forma bastante desigual (21 u.t. para o Processo A e 6 u.t. para o Processo B). Como a característica do Processo B é realizar muitas operações de E/S, em grande parte do tempo o processo permanecerá no estado de espera.

A próxima figura, que segue logo abaixo deste trecho apresenta os mesmos processos A e B, só que aplicando o escalonamento circular com fatia de tempo igual a cinco unidades de tempo. Com isso, o escalonamento circular consegue melhorar a distribuição do tempo de processador (15 u.t. para o Processo A e 10 u.t. para o Processo B) em relação ao escalonamento FIFO, porém ainda não consegue implementar um compartilhamento equitativo entre os diferentes tipos de processos. Esta deficiência no escalonamento circular deve-se ao fato de todos os processos serem tratados de uma maneira igual, o que nem sempre é desejável.

Em um escalonamento onde todos os processos são tratados igualmente, processos CPU-bound sempre levam vantagem sobre processos I/O-bound no uso do processador. Como no escalonamento circular um processo I/O-bound compete pelo processador da mesma forma que um processo CPU-bound e o processo I/O-bound passa a maior parte do tempo no estado de espera, o processo CPU-bound tem mais oportunidade de ser executado.
No escalonamento circular com prioridades é possível associar prioridades maiores aos processos I/O-bound, a fim de compensar o excessivo tempo gasto por este tipo de processo no estado de espera. No exemplo da que segue logo após esse trecho do texto, o Processo B tem uma prioridade superior à do Processo A, obtendo-se, desta forma, um maior grau de compartilhamento no uso do processador (12 u.t. para o Processo A e 13 u.t. para o Processo B).

Embora os sistemas com prioridade dinâmica sejam mais complexos de implementar que os sistemas com prioridade estática, o tempo de resposta oferecido compensa. Atualmente, a maioria dos sistemas operacionais de tempo compartilhado utiliza o escalonamento circular com prioridades dinâmicas.


IMAGENS_SISTEMA_TEMPO_COMPARTILHADO

CONCLUSÃO SOBRE SISTEMA TEMPO COMPARTILHADO:

Estas políticas de escalonamento são, por exemplo, aquelas que usamos em casa este computador que uso para editar este relatório que está com cara de seminário. Infelizmente não encontrei muitos documentos que falassem sobre essa política de escalonamento, contudo, vale lembrar que vimos muito isso nas aulas de Sistemas Operacionais lecionada pelo professor Fábio, e forma simples e objetiva é possível fazer algumas afirmações que nos fazem entender melhor essa política de escalonamento:

1.	Um processo CPU-bound sempre leva vantagem sobre um processo I/O-bound. Isso porque o processo I/O-bound estará em espera na maior parte do tempo. Por exemplo: este editor de texto que estou usando está – esperando – eu salvar o documento para efetuar o processo de salvamento em disco. Isto é, enquanto eu não apertar CTRL + B no meu Office Word ele não salvará, e outros processos estão executando à frente deste processo de salvamento, pois esse processo depende da minha interação.

2.	 Os sistemas com política de escalonamento de tempo compartilhado costumam aumentar a prioridade de processos I/O-bound afim de minimizar o tempo desses processos, já que se encontram a maior parte do tempo no modo de espera.

(PESQUISAR MAIS COISAS?)

Política de Escalonamento em Sistemas de Tempo Real

Diferente dos sistemas de tempo compartilhado, nos quais a aplicação não é prejudicada pela variação no tempo de resposta, algumas aplicações especificas exigem respostas imediatas para a execução de determinadas tarefas. Neste caso, a aplicação deve ser executada em sistemas operacionais de tempo real, onde é garantida a execução de processos dentro de limites rígidos de tempo, sem o risco de a aplicação ficar comprometida. Aplicações de controle de processos, como sistemas de controle de produção de bens industriais e controle de tráfego aéreo, são exemplos de aplicação de tempo real.

O escalonamento em sistemas de tempo real deve levar em consideração a importância relativa de cada tarefa na aplicação. Em função disso, o escalonamento por prioridades é o mais adequado, já́ que para cada processo uma prioridade é associada em função da importância do processo dentro da aplicação. No escalonamento para sistemas de tempo real não deve existir o conceito de fatia de tempo, e a prioridade de cada processo deve ser estática.

CONCLUSÃO SISTEMA TEMPO REAL:

Podemos ver observando a política de escalonamento de tempo compartilhado e traçando um paralelo com a política de escalonamento em sistemas de tempo real que enquanto a primeira se preocupa mais com o conforto do usuário final, como um documento de texto que salva quase que imediatamente, a segunda se preocupa em tempo de resposta para processos que exigem atenção, afinal, esses sistemas de tempo real são usados nas áreas de saúde, trafego aéreo, usinas nucleares e outros campos onde exige um sistema de resposta imediata, e onde a otimização e a priorização dos processos certos é importantíssima. Seguindo essa linha e sumarizando as características da politica de escalonamento em sistemas de tempo real em comparação à politica de escalonamento de tempo compartilhado podemos dizer:

1.	O uso dos recursos computacionais de um sistema de tempo real é definido pela prioridade que a aplicação indicar. Exemplo: uma daquelas máquinas do hospital que monitora batimentos cardíacos e sinais vitais de um paciente.

2.	Não há fatia de tempo. Exemplo: seguindo o exemplo anterior, imagine parar por alguns segundos de monitorar os batimentos cardíacos e sinais vitais de um paciente, não é uma opção válida, então a política de time-slice ou quantum, como também é chamada, está fora de questão.

3.	Esses sistemas não são destinados ao usuário final, como dito anteriormente. São sistemas com aplicações para situações críticas. Aplicações mais comerciais usaram quase sempre (se não sempre) sistemas de tempo compartilhado para oferecer melhor experiência de usuário.



Escalonamento Earliest Deadline First (EDF)

O "Earliest Deadline First" (EDF) define um escalonamento baseado em prioridades: a escala é produzida em tempo de execução por um escalonador preemptivo dirigido a prioridades. É um esquema de prioridades dinâmicas com um escalonamento "on-line" e dinâmico. O EDF é um algoritmo ótimo na classe dos escalonamentos de prioridade dinâmica. As premissas que determinam o modelo de tarefas no EDF são:
1.	As tarefas são periódicas e independentes.
2.	O "deadline" de cada tarefa coincide com o seu período (Di=Pi). (Onde D é deadline e P é período)
3.	O tempo de computação (Ci) de cada tarefa é conhecido e constante (“Worst Case Computation Time”).
4.	O tempo de chaveamento entre tarefas é assumido como nulo.

A política de escalonamento no EDF corresponde a uma atribuição dinâmica de prioridades que define a ordenação das tarefas segundo os seus "deadlines" absolutos (di). A tarefa mais prioritária é a que tem o "deadline" di mais próximo do tempo atual.

A cada chegada de tarefa a fila de prontos é reordenada, considerando a nova distribuição de prioridades. A cada ativação de uma tarefa Ti, um novo prazo absoluto é determinado considerando o número de períodos que antecede a atual ativação. No EDF, a escalabilidade é também verificada em tempo de projeto, tomando como base a utilização do processador.
